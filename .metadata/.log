!SESSION 2022-04-16 21:34:12.582 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\demis\OneDrive\Documents\NetBeansProjects\.metadata\.bak_0.log
Created Time: 2022-04-17 20:55:11.404

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:11.404
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:11.410
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:13.604
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:13.605
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:13.605
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:15.237
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:15.238
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:15.238
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:20.890
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:20.891
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:20.891
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:27.448
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:27.449
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:27.449
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:32.071
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:32.072
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:32.072
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:35.934
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:35.935
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:35.935
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:38.782
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:38.782
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:38.783
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:40.021
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:40.022
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:40.022
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:43.496
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:43.496
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:43.497
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:46.041
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:46.042
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:46.042
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:47.475
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:47.476
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:47.476
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:50.311
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:50.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:50.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:52.025
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:52.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:52.026
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:56:22.271
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:56:22.271
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:56:22.272
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:56:22.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:56:22.340
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:56:22.341
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2022-04-22 01:26:41.776 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-22 01:26:47.913
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-22 01:26:47.913
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e52d2f2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12608986,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-22 01:26:47.913
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4882b9a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ec508e6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-22 01:26:51.013
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\demis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
