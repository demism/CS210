!SESSION 2022-02-28 00:25:37.059 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-28 00:26:09.728
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-28 00:26:09.728
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-28 00:26:09.728
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-28 00:26:13.628
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\demis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-28 00:34:43.663 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/C:/Users/demis/OneDrive/Documents/NetBeansProjects/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-28 00:34:46.108
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-28 00:34:46.108
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3722f39d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec8d9b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-28 00:34:46.108
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57b63253,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c0013b8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-28 00:34:48.983
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\demis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-03 22:21:45.010 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2022-03-03 22:21:56.080
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-03-03 22:21:56.080
!MESSAGE Could not read metadata for 'Topic8project'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Topic8project)[567]: java.lang.Exception: The project description file (.project) for 'Topic8project' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:384)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:471)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:403)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-03-03 22:21:56.082
!MESSAGE The project description file (.project) for 'Topic8project' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Topic8project' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:384)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:471)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:403)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jface 2 0 2022-03-03 22:21:59.113
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 22:21:59.114
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12d44a2a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a66be41,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 22:21:59.114
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f70e244,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@fd14789,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-03 22:22:04.115
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\demis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-16 21:34:12.582 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-16 21:34:21.716
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-16 21:34:21.716
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f65aa58,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@749f61a3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-16 21:34:21.716
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36d7a68a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42dd7d82,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-16 21:34:24.653
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\demis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 16:45:12.504
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * /Program to manage a list of rainfall records for a specific US city
 * with monthly rainfall amounts recorded.
 * Rain measurement data for the city will be read from a text file.
 * The user will be able to display the rainfall list, determine the average
 * rainfall for any particular month, find the date(s) that had the most and
 * least amount rainfall, insert new records into the list, and re-save the
 * rainfall data to a new file.
 * 
 * @author Demis Mota
 * @version 1.0
 */

import java.io.IOException;
import java.util.Scanner;

public class RainRecordsManager {
   final static int EARLIEST_YEAR = 1900;  // earliest rain measured
   final static int CURRENT_YEAR = 2021;   // latest rain measured

   /**
    * Creates cityRain data structure for one city,
    * reads data from an input file, and then lets the user manage the 
    * data structure via a menu of options, until the user chooses to exit.
    * 
    * @param args the command line arguments
    */
   public static void main(String[] args) {
      char choice = 0;
      String filename = null;
      int amountRainData = 0;
     // FIX ME - declare additional variables here
      
      // Instantiate a Scanner object to read from the keyboard
      Scanner keyboard = new Scanner(System.in);
      
      // Instantiate a CityMonthlyRainListImpl object named cityRain
      // The object will contain null location values and an
      // instantiated, but empty, RainFall ArrayList data structure
      CityMonthlyRainListImpl cityRain = new CityMonthlyRainListImpl();
      
      // Read and store the user-entered location into cityRain
      // then display a program header
      cityRain.readLocation(keyboard);
      System.out.println();      
      System.out.println("Program to manage rainfall records for " +
            cityRain.getCity() + ", " + cityRain.getState());
      System.out.println();
      
      filename = cityRain.getCity().replace(" ", "") + "rain.txt";
      try {
    	  amountRainData = cityRain.readRainDataFile(filename);
    	  System.out.println("Stored rainfall data for " + amountRainData + " months");
    	  while (choice != 'E')
    	  {
    		  choice = displayMenu(keyboard);
    		  switch (choice) {
    		  case 'D':
    			  cityRain.displayRainList();
    			  break;
    		  case 'Y':
    			  break;
    		  case 'A':
    			  break;
    		  case 'M':
    			  break;
    		  case 'L':
    			  break;
    		  case 'I':
    			  break;
    		  case 'U':
    			  break;
    		  case 'E':
    			  break;
    		  }
    	  }
      }
      catch (IOException ioe) {
    	  System.out.println("ERROR: Cannot read input file " + filename);
    	  System.out.println("**Program exiting");
      }
   }
   
   /**
    * Method displays menu to user and then
    * reads, uppercases, validates, and returns user choice from a menu
    * 
    * @param Scanner input
    * @return choice character
    */
   public static char displayMenu (Scanner input) {
	   
	   String choice;
	   boolean loop = true;
	   String regex = "^[DYAMLIUE]$";
	   
	   do {
		   System.out.println();
		   System.out.println("MENU");
		   System.out.println("  D = Display all monthly rain measurements");
		   System.out.println("  Y = Display monthly rain measurements for one Year");
		   System.out.println("  A = Average rainfall for one month");
		   System.out.println("  M = Most rain in one month");
		   System.out.println("  L = Least rain in one month");
		   System.out.println("  I = Insert a new monthly rain measure record");
		   System.out.println("  U = Update rain data file");
		   System.out.println("  E = Exit program");
		   System.out.println("Enter choice:");
		   choice = input.nextLine().toUpperCase();
		   if (choice.matches(regex))
			   loop = false;
		   else
			   System.out.println("ERROR: Invalid menu choice! Try again.");
	   } while (loop);
	   return choice.charAt(0);
   }
   
   /**
    * Method readDateNum will read an integer from the user 
    * until a valid value between the minimum and maximum parameters 
    * is entered 
    * 
    * @param Scanner input
    * @param String prompt
    * @param int min, int max // min-max allowable year
    * @return valid year
    */
   public static int readDateNum ( Scanner input, String prompt, int min, int max) {
      int year;
	   
      ifSystem.out.println("Enter the " + prompt);
      year = input.nextInt(); (year < min || year > max)
    	  System.out.println("ERROR: Invalid " + prompt + ". Value must be between " 
    			  + min + " and " + max);
      
      return year;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 16:45:12.505
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 16:45:12.505
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 16:45:12.660
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * /Program to manage a list of rainfall records for a specific US city
 * with monthly rainfall amounts recorded.
 * Rain measurement data for the city will be read from a text file.
 * The user will be able to display the rainfall list, determine the average
 * rainfall for any particular month, find the date(s) that had the most and
 * least amount rainfall, insert new records into the list, and re-save the
 * rainfall data to a new file.
 * 
 * @author Demis Mota
 * @version 1.0
 */

import java.io.IOException;
import java.util.Scanner;

public class RainRecordsManager {
   final static int EARLIEST_YEAR = 1900;  // earliest rain measured
   final static int CURRENT_YEAR = 2021;   // latest rain measured

   /**
    * Creates cityRain data structure for one city,
    * reads data from an input file, and then lets the user manage the 
    * data structure via a menu of options, until the user chooses to exit.
    * 
    * @param args the command line arguments
    */
   public static void main(String[] args) {
      char choice = 0;
      String filename = null;
      int amountRainData = 0;
     // FIX ME - declare additional variables here
      
      // Instantiate a Scanner object to read from the keyboard
      Scanner keyboard = new Scanner(System.in);
      
      // Instantiate a CityMonthlyRainListImpl object named cityRain
      // The object will contain null location values and an
      // instantiated, but empty, RainFall ArrayList data structure
      CityMonthlyRainListImpl cityRain = new CityMonthlyRainListImpl();
      
      // Read and store the user-entered location into cityRain
      // then display a program header
      cityRain.readLocation(keyboard);
      System.out.println();      
      System.out.println("Program to manage rainfall records for " +
            cityRain.getCity() + ", " + cityRain.getState());
      System.out.println();
      
      filename = cityRain.getCity().replace(" ", "") + "rain.txt";
      try {
    	  amountRainData = cityRain.readRainDataFile(filename);
    	  System.out.println("Stored rainfall data for " + amountRainData + " months");
    	  while (choice != 'E')
    	  {
    		  choice = displayMenu(keyboard);
    		  switch (choice) {
    		  case 'D':
    			  cityRain.displayRainList();
    			  break;
    		  case 'Y':
    			  break;
    		  case 'A':
    			  break;
    		  case 'M':
    			  break;
    		  case 'L':
    			  break;
    		  case 'I':
    			  break;
    		  case 'U':
    			  break;
    		  case 'E':
    			  break;
    		  }
    	  }
      }
      catch (IOException ioe) {
    	  System.out.println("ERROR: Cannot read input file " + filename);
    	  System.out.println("**Program exiting");
      }
   }
   
   /**
    * Method displays menu to user and then
    * reads, uppercases, validates, and returns user choice from a menu
    * 
    * @param Scanner input
    * @return choice character
    */
   public static char displayMenu (Scanner input) {
	   
	   String choice;
	   boolean loop = true;
	   String regex = "^[DYAMLIUE]$";
	   
	   do {
		   System.out.println();
		   System.out.println("MENU");
		   System.out.println("  D = Display all monthly rain measurements");
		   System.out.println("  Y = Display monthly rain measurements for one Year");
		   System.out.println("  A = Average rainfall for one month");
		   System.out.println("  M = Most rain in one month");
		   System.out.println("  L = Least rain in one month");
		   System.out.println("  I = Insert a new monthly rain measure record");
		   System.out.println("  U = Update rain data file");
		   System.out.println("  E = Exit program");
		   System.out.println("Enter choice:");
		   choice = input.nextLine().toUpperCase();
		   if (choice.matches(regex))
			   loop = false;
		   else
			   System.out.println("ERROR: Invalid menu choice! Try again.");
	   } while (loop);
	   return choice.charAt(0);
   }
   
   /**
    * Method readDateNum will read an integer from the user 
    * until a valid value between the minimum and maximum parameters 
    * is entered 
    * 
    * @param Scanner input
    * @param String prompt
    * @param int min, int max // min-max allowable year
    * @return valid year
    */
   public static int readDateNum ( Scanner input, String prompt, int min, int max) {
      int year;
	   
      ifSystem.out.println("Enter the " + prompt);
      year = input.nextInt(); (year < min || year > max)
    	  System.out.println("ERROR: Invalid " + prompt + ". Value must be between " 
    			  + min + " and " + max);
      
      return year;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 16:45:12.660
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 16:45:12.661
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 16:45:19.306
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * /Program to manage a list of rainfall records for a specific US city
 * with monthly rainfall amounts recorded.
 * Rain measurement data for the city will be read from a text file.
 * The user will be able to display the rainfall list, determine the average
 * rainfall for any particular month, find the date(s) that had the most and
 * least amount rainfall, insert new records into the list, and re-save the
 * rainfall data to a new file.
 * 
 * @author Demis Mota
 * @version 1.0
 */

import java.io.IOException;
import java.util.Scanner;

public class RainRecordsManager {
   final static int EARLIEST_YEAR = 1900;  // earliest rain measured
   final static int CURRENT_YEAR = 2021;   // latest rain measured

   /**
    * Creates cityRain data structure for one city,
    * reads data from an input file, and then lets the user manage the 
    * data structure via a menu of options, until the user chooses to exit.
    * 
    * @param args the command line arguments
    */
   public static void main(String[] args) {
      char choice = 0;
      String filename = null;
      int amountRainData = 0;
     // FIX ME - declare additional variables here
      
      // Instantiate a Scanner object to read from the keyboard
      Scanner keyboard = new Scanner(System.in);
      
      // Instantiate a CityMonthlyRainListImpl object named cityRain
      // The object will contain null location values and an
      // instantiated, but empty, RainFall ArrayList data structure
      CityMonthlyRainListImpl cityRain = new CityMonthlyRainListImpl();
      
      // Read and store the user-entered location into cityRain
      // then display a program header
      cityRain.readLocation(keyboard);
      System.out.println();      
      System.out.println("Program to manage rainfall records for " +
            cityRain.getCity() + ", " + cityRain.getState());
      System.out.println();
      
      filename = cityRain.getCity().replace(" ", "") + "rain.txt";
      try {
    	  amountRainData = cityRain.readRainDataFile(filename);
    	  System.out.println("Stored rainfall data for " + amountRainData + " months");
    	  while (choice != 'E')
    	  {
    		  choice = displayMenu(keyboard);
    		  switch (choice) {
    		  case 'D':
    			  cityRain.displayRainList();
    			  break;
    		  case 'Y':
    			  break;
    		  case 'A':
    			  break;
    		  case 'M':
    			  break;
    		  case 'L':
    			  break;
    		  case 'I':
    			  break;
    		  case 'U':
    			  break;
    		  case 'E':
    			  break;
    		  }
    	  }
      }
      catch (IOException ioe) {
    	  System.out.println("ERROR: Cannot read input file " + filename);
    	  System.out.println("**Program exiting");
      }
   }
   
   /**
    * Method displays menu to user and then
    * reads, uppercases, validates, and returns user choice from a menu
    * 
    * @param Scanner input
    * @return choice character
    */
   public static char displayMenu (Scanner input) {
	   
	   String choice;
	   boolean loop = true;
	   String regex = "^[DYAMLIUE]$";
	   
	   do {
		   System.out.println();
		   System.out.println("MENU");
		   System.out.println("  D = Display all monthly rain measurements");
		   System.out.println("  Y = Display monthly rain measurements for one Year");
		   System.out.println("  A = Average rainfall for one month");
		   System.out.println("  M = Most rain in one month");
		   System.out.println("  L = Least rain in one month");
		   System.out.println("  I = Insert a new monthly rain measure record");
		   System.out.println("  U = Update rain data file");
		   System.out.println("  E = Exit program");
		   System.out.println("Enter choice:");
		   choice = input.nextLine().toUpperCase();
		   if (choice.matches(regex))
			   loop = false;
		   else
			   System.out.println("ERROR: Invalid menu choice! Try again.");
	   } while (loop);
	   return choice.charAt(0);
   }
   
   /**
    * Method readDateNum will read an integer from the user 
    * until a valid value between the minimum and maximum parameters 
    * is entered 
    * 
    * @param Scanner input
    * @param String prompt
    * @param int min, int max // min-max allowable year
    * @return valid year
    */
   public static int readDateNum ( Scanner input, String prompt, int min, int max) {
      int year;
	   
      ifSystem.out.println("Enter the " + prompt);
      year = input.nextInt(); (year < min || year > max)
    	  System.out.println("ERROR: Invalid " + prompt + ". Value must be between " 
    			  + min + " and " + max);
      
      return year;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 16:45:19.307
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 16:45:19.307
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 16:45:20.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * /Program to manage a list of rainfall records for a specific US city
 * with monthly rainfall amounts recorded.
 * Rain measurement data for the city will be read from a text file.
 * The user will be able to display the rainfall list, determine the average
 * rainfall for any particular month, find the date(s) that had the most and
 * least amount rainfall, insert new records into the list, and re-save the
 * rainfall data to a new file.
 * 
 * @author Demis Mota
 * @version 1.0
 */

import java.io.IOException;
import java.util.Scanner;

public class RainRecordsManager {
   final static int EARLIEST_YEAR = 1900;  // earliest rain measured
   final static int CURRENT_YEAR = 2021;   // latest rain measured

   /**
    * Creates cityRain data structure for one city,
    * reads data from an input file, and then lets the user manage the 
    * data structure via a menu of options, until the user chooses to exit.
    * 
    * @param args the command line arguments
    */
   public static void main(String[] args) {
      char choice = 0;
      String filename = null;
      int amountRainData = 0;
     // FIX ME - declare additional variables here
      
      // Instantiate a Scanner object to read from the keyboard
      Scanner keyboard = new Scanner(System.in);
      
      // Instantiate a CityMonthlyRainListImpl object named cityRain
      // The object will contain null location values and an
      // instantiated, but empty, RainFall ArrayList data structure
      CityMonthlyRainListImpl cityRain = new CityMonthlyRainListImpl();
      
      // Read and store the user-entered location into cityRain
      // then display a program header
      cityRain.readLocation(keyboard);
      System.out.println();      
      System.out.println("Program to manage rainfall records for " +
            cityRain.getCity() + ", " + cityRain.getState());
      System.out.println();
      
      filename = cityRain.getCity().replace(" ", "") + "rain.txt";
      try {
    	  amountRainData = cityRain.readRainDataFile(filename);
    	  System.out.println("Stored rainfall data for " + amountRainData + " months");
    	  while (choice != 'E')
    	  {
    		  choice = displayMenu(keyboard);
    		  switch (choice) {
    		  case 'D':
    			  cityRain.displayRainList();
    			  break;
    		  case 'Y':
    			  break;
    		  case 'A':
    			  break;
    		  case 'M':
    			  break;
    		  case 'L':
    			  break;
    		  case 'I':
    			  break;
    		  case 'U':
    			  break;
    		  case 'E':
    			  break;
    		  }
    	  }
      }
      catch (IOException ioe) {
    	  System.out.println("ERROR: Cannot read input file " + filename);
    	  System.out.println("**Program exiting");
      }
   }
   
   /**
    * Method displays menu to user and then
    * reads, uppercases, validates, and returns user choice from a menu
    * 
    * @param Scanner input
    * @return choice character
    */
   public static char displayMenu (Scanner input) {
	   
	   String choice;
	   boolean loop = true;
	   String regex = "^[DYAMLIUE]$";
	   
	   do {
		   System.out.println();
		   System.out.println("MENU");
		   System.out.println("  D = Display all monthly rain measurements");
		   System.out.println("  Y = Display monthly rain measurements for one Year");
		   System.out.println("  A = Average rainfall for one month");
		   System.out.println("  M = Most rain in one month");
		   System.out.println("  L = Least rain in one month");
		   System.out.println("  I = Insert a new monthly rain measure record");
		   System.out.println("  U = Update rain data file");
		   System.out.println("  E = Exit program");
		   System.out.println("Enter choice:");
		   choice = input.nextLine().toUpperCase();
		   if (choice.matches(regex))
			   loop = false;
		   else
			   System.out.println("ERROR: Invalid menu choice! Try again.");
	   } while (loop);
	   return choice.charAt(0);
   }
   
   /**
    * Method readDateNum will read an integer from the user 
    * until a valid value between the minimum and maximum parameters 
    * is entered 
    * 
    * @param Scanner input
    * @param String prompt
    * @param int min, int max // min-max allowable year
    * @return valid year
    */
   public static int readDateNum ( Scanner input, String prompt, int min, int max) {
      int year;
	   
      ifSystem.out.println("Enter the " + prompt);
      year = input.nextInt(); (year < min || year > max)
    	  System.out.println("ERROR: Invalid " + prompt + ". Value must be between " 
    			  + min + " and " + max);
      
      return year;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 16:45:20.277
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 16:45:20.278
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 16:45:20.567
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * /Program to manage a list of rainfall records for a specific US city
 * with monthly rainfall amounts recorded.
 * Rain measurement data for the city will be read from a text file.
 * The user will be able to display the rainfall list, determine the average
 * rainfall for any particular month, find the date(s) that had the most and
 * least amount rainfall, insert new records into the list, and re-save the
 * rainfall data to a new file.
 * 
 * @author Demis Mota
 * @version 1.0
 */

import java.io.IOException;
import java.util.Scanner;

public class RainRecordsManager {
   final static int EARLIEST_YEAR = 1900;  // earliest rain measured
   final static int CURRENT_YEAR = 2021;   // latest rain measured

   /**
    * Creates cityRain data structure for one city,
    * reads data from an input file, and then lets the user manage the 
    * data structure via a menu of options, until the user chooses to exit.
    * 
    * @param args the command line arguments
    */
   public static void main(String[] args) {
      char choice = 0;
      String filename = null;
      int amountRainData = 0;
     // FIX ME - declare additional variables here
      
      // Instantiate a Scanner object to read from the keyboard
      Scanner keyboard = new Scanner(System.in);
      
      // Instantiate a CityMonthlyRainListImpl object named cityRain
      // The object will contain null location values and an
      // instantiated, but empty, RainFall ArrayList data structure
      CityMonthlyRainListImpl cityRain = new CityMonthlyRainListImpl();
      
      // Read and store the user-entered location into cityRain
      // then display a program header
      cityRain.readLocation(keyboard);
      System.out.println();      
      System.out.println("Program to manage rainfall records for " +
            cityRain.getCity() + ", " + cityRain.getState());
      System.out.println();
      
      filename = cityRain.getCity().replace(" ", "") + "rain.txt";
      try {
    	  amountRainData = cityRain.readRainDataFile(filename);
    	  System.out.println("Stored rainfall data for " + amountRainData + " months");
    	  while (choice != 'E')
    	  {
    		  choice = displayMenu(keyboard);
    		  switch (choice) {
    		  case 'D':
    			  cityRain.displayRainList();
    			  break;
    		  case 'Y':
    			  break;
    		  case 'A':
    			  break;
    		  case 'M':
    			  break;
    		  case 'L':
    			  break;
    		  case 'I':
    			  break;
    		  case 'U':
    			  break;
    		  case 'E':
    			  break;
    		  }
    	  }
      }
      catch (IOException ioe) {
    	  System.out.println("ERROR: Cannot read input file " + filename);
    	  System.out.println("**Program exiting");
      }
   }
   
   /**
    * Method displays menu to user and then
    * reads, uppercases, validates, and returns user choice from a menu
    * 
    * @param Scanner input
    * @return choice character
    */
   public static char displayMenu (Scanner input) {
	   
	   String choice;
	   boolean loop = true;
	   String regex = "^[DYAMLIUE]$";
	   
	   do {
		   System.out.println();
		   System.out.println("MENU");
		   System.out.println("  D = Display all monthly rain measurements");
		   System.out.println("  Y = Display monthly rain measurements for one Year");
		   System.out.println("  A = Average rainfall for one month");
		   System.out.println("  M = Most rain in one month");
		   System.out.println("  L = Least rain in one month");
		   System.out.println("  I = Insert a new monthly rain measure record");
		   System.out.println("  U = Update rain data file");
		   System.out.println("  E = Exit program");
		   System.out.println("Enter choice:");
		   choice = input.nextLine().toUpperCase();
		   if (choice.matches(regex))
			   loop = false;
		   else
			   System.out.println("ERROR: Invalid menu choice! Try again.");
	   } while (loop);
	   return choice.charAt(0);
   }
   
   /**
    * Method readDateNum will read an integer from the user 
    * until a valid value between the minimum and maximum parameters 
    * is entered 
    * 
    * @param Scanner input
    * @param String prompt
    * @param int min, int max // min-max allowable year
    * @return valid year
    */
   public static int readDateNum ( Scanner input, String prompt, int min, int max) {
      int year;
	   
      ifSystem.out.println("Enter the " + prompt);
      year = input.nextInt(); (year < min || year > max)
    	  System.out.println("ERROR: Invalid " + prompt + ". Value must be between " 
    			  + min + " and " + max);
      
      return year;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 16:45:20.567
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 16:45:20.568
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:42:53.609
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      for (int i = 0; i < monthlyRainList.size(); i++)
      {
    	  tempRF = monthlyRainList.get(i);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(i).setMeasuredRain(rain);
    	  }
    	  else 
    	  {
    		  if ( tempRF.getYear() == year ) && tempRF.getMonth() < month )
    	  }
      
      }
   }
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:42:53.610
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:42:53.610
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:42:54.780
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      for (int i = 0; i < monthlyRainList.size(); i++)
      {
    	  tempRF = monthlyRainList.get(i);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(i).setMeasuredRain(rain);
    	  }
    	  else 
    	  {
    		  if ( tempRF.getYear() == year ) && tempRF.getMonth() < month )
    	  }
      
      }
   }
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:42:54.781
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:42:54.781
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:36.209
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:36.210
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:36.210
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:37.218
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  0
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:37.219
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:37.220
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:39.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  04/2012
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:39.728
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:39.728
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:40.814
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  04/2012
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:52:40.815
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:52:40.816
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:42.237
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  04/2012
    		  
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:42.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:42.238
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:46.747
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:46.748
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:46.748
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:47.752
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:52:47.753
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:52:47.754
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:51.258
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/20
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:51.259
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:51.259
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:51.267
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/20
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:52:51.268
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:52:51.268
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:53.268
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:52:53.269
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:52:53.269
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:54.108
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:52:54.109
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:52:54.109
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:52:57.058
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:52:57.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:52:57.059
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:32.420
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:32.420
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:32.421
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:40.825
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:40.826
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:40.826
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:43.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:43.547
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:43.548
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:46.650
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:46.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:46.651
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:49.328
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:53:49.329
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:53:49.329
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:50.230
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:50.231
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:50.232
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:52.837
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:53:52.837
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:53:52.838
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:53.710
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:53.711
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:53.711
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:57.847
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===>10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:53:57.847
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:53:57.848
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:58.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:53:58.859
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:53:58.859
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:53:59.853
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:53:59.853
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:53:59.854
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:01.410
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:01.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:01.411
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:07.373
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:07.374
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:07.374
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:08.881
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<====>
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:08.881
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:08.882
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:13.400
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2009
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:13.401
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:13.401
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:13.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2009
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:13.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:13.412
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:15.237
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2009
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:15.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:15.238
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:17.412
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:17.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:17.413
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:20.062
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:20.063
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:20.063
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:23.424
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===>
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:23.424
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:23.425
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:24.932
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:24.932
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:24.933
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:24.940
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:24.940
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:24.941
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:28.442
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/20
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:28.443
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:28.444
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:31.952
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===02/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:31.953
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:31.953
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:31.961
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===02/2014
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:31.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:31.962
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:33.461
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===02/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:33.462
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:33.462
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:33.470
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===02/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:33.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:33.471
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:38.972
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-17 20:54:38.973
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-17 20:54:38.973
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:38.981
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:38.981
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:38.982
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:41.699
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:41.700
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:41.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:54:57.201
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:54:57.202
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:54:57.202
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:00.115
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-17 20:55:00.115
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-17 20:55:00.116
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-17 20:55:11.402
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/**
 * Class to define data fields and methods for an ArrayList of RainFall objects
 * which represents a list of measured rainfall amounts in one city
 * during various months 
 * 
 * Stores the city, state, and list of rainfall data for one city
 * Includes methods to display items in the monthlyRainList, add a measurement, 
 * update a measurement, find the month with the highest rainfall amount, 
 * and re-save the rainfall data to another file.
 * 
 * @author Demis Mota
 * @version 1.0
 */
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class CityMonthlyRainListImpl {
	final static double MAX_RAIN = 100.00;
   private String city;
   private String state;
   private ArrayList<RainFall> monthlyRainList;

   /**
    * Default constructor
    */
   public CityMonthlyRainListImpl() {
      this.city = null;
      this.state = null;
      this.monthlyRainList = new ArrayList<RainFall>();
   }

   /**
    * Getter for city
    * 
    * @return city
    */
   public String getCity() {
      return city;
   }

   /**
    * Setter for city
    * 
    * @param city 
    */
   public void setCity(String city) {
      this.city = city;
   }

   /**
    * Getter for state
    * 
    * @return state 
    */
   public String getState() {
      return state;
   }

   /**
    * Setter for state
    * 
    * @param state 
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Getter for monthlyRainList
    * NOTE:  Used for testing -- do NOT delete
    * 
    * @return monthlyRainList
    */
   public ArrayList<RainFall> getMonthlyRainList() {
      return monthlyRainList;
   }

   /**
     * Method readLocation will read and error check location entered by user 
     * and set the city and state data fields with validated values
	  * 
     * @param keyboard - Scanner to read user input from keyboard
     */
   public void readLocation(Scanner keyboard) {
	  boolean loop = true;
      String input = null;
      String regex = "^[a-zA-Z-]*[\\ ]?[a-zA-Z-]*$";
      String regex2 = "^[a-zA-Z][a-zA-Z]$";
      
      while (loop) 
      {
    	  System.out.println("Enter city:");
       	  input = keyboard.nextLine().toUpperCase();
       	  if (input.matches(regex)) {
       		setCity(input);
       		loop = false;
       	  }
       	  else
       		  System.out.println("ERROR: " + input + " is not a valid city name");
      }
      
      
      loop = true;
      while (loop)
      {
    	  System.out.println("Enter two-letter state abbreviation:");
    	  input = keyboard.nextLine().toUpperCase();
    	  if (input.matches(regex2)) {
    		  setState(input);
       		  loop = false;       		  
    	  }
    	  else
    		  System.out.println("ERROR: " + input + " is not a valid state abbreviation");
      }
   }
   
   /**
    * Method readRainDataFile will read data from input data file
    * Each line will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
    * The method will create a RainFall object from each line of data, 
    * and place the object into the monthlyRainList ArrayList.
	 * Thrown exceptions are handled by the caller.
    * 
    * @param filename
    * @throws IOException automatically, when input file cannot be opened
    * @return monthlyRainList size
    */
   public int readRainDataFile(String filename) throws IOException {
	   FileInputStream fbs = null;
	   int month;
	   int year;
	   double amtRain;
	   
	   fbs = new FileInputStream(filename);
	   Scanner infile = new Scanner(fbs);
	   
	   while (infile.hasNext())
	   {
		   month = infile.nextInt();
		   year = infile.nextInt();
		   amtRain = infile.nextDouble();
		   monthlyRainList.add(new RainFall(month,year,amtRain));
	   }
	   infile.close();
	   fbs.close();
	   return monthlyRainList.size();
   }
 
   /**
    * Method displayRainList will display rainfall for all dates
    */ 
   public void displayRainList() {
	   int count = 0;
	   RainFall rf = null;
      System.out.println();
      System.out.println(getCity() + ", " + getState() + " monthly rainfall records");
      while ( count < monthlyRainList.size() ) {
    	  rf = monthlyRainList.get(count);
    	  System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
    	  count++;
      }
   }
   
   /**
    * Overloaded method displayRainList will display rainfall 
    * for all stored months within one year, along with a total
    * 
    * @param int year
    */
   public void displayRainList(int year) {
	   int count = 0;
	   int months = 0;
	   double totalRain = 0.0;
	   RainFall rf = null;
	   
	   System.out.println();
	   System.out.println(getCity() + ", " + getState() + " monthly rainfall records for " + year);
	   while ( count < monthlyRainList.size()) {
		   rf = monthlyRainList.get(count);
		   if ( year == rf.getYear()) {
			   System.out.printf("  %02d/%d had %.2f inches of rain\n", rf.getMonth(), rf.getYear(), rf.getMeasuredRain());
			   months++;
			   totalRain += rf.getMeasuredRain();
		   }
		   count++;
	   }
	   System.out.printf("Total of %.2f inches of rain over %d months",totalRain,months);
	   System.out.println();
   }
 
   /**
    * Method calcAverageRainForMonth will calculate the average rainfall 
    * for one month, for all years stored
    * 
    * @param int month
    * @return averageRainFall
    */
   public double calcAverageRainForMonth(int month) {
      double averageRainFall = 0.00;
      double totalRainFall = 0.00;
      int totalMonths = 0;
      RainFall rf = null;
      
      for (int i=0; i < monthlyRainList.size(); i++)
      {
    	  rf = monthlyRainList.get(i);
    	  if ( month == rf.getMonth())
    	  {
    		totalMonths++;
    		totalRainFall += rf.getMeasuredRain();
    	  }
      }
      averageRainFall = totalRainFall / totalMonths;
      return averageRainFall;
   }
   
   /**
    * Method displayHighestRainDates will display date(s) with highest rainfall
    */ 
   public void displayHighestRainDates() {
	   double highestRate = 0.0;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() > highestRate)
			   highestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with most rain (%.2f inches) measured:\n", city, state, highestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == highestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
   }
   
   /**
    * Method displayLowestRainDates will display date(s) with lowest rainfall
    */ 
   public void displayLowestRainDates() {
	   double lowestRate = MAX_RAIN;
	   for (int i=0; i < monthlyRainList.size(); i++) {
		   if ( monthlyRainList.get(i).getMeasuredRain() < lowestRate)
			   lowestRate = monthlyRainList.get(i).getMeasuredRain();		   
	   }
	   
	   System.out.printf("%s, %s date(s) with least rain (%.2f inches) measured:\n", city, state, lowestRate);
	   
	   for (int i = 0; i < monthlyRainList.size(); i++) {
		   RainFall rf = monthlyRainList.get(i);
		   if ( rf.getMeasuredRain() == lowestRate) {
			   System.out.printf("  %02d/%d\n", rf.getMonth(), rf.getYear());
		   }
	   }
      
   }
   
  /**
    * Method insertMonthsRainFallRecord will insert a new rainfall record 
    * into the ArrayList in the correct location
    * (or modify the rainfall measurement of an exisiting record)
    * 
    * @param month - of date to add
    * @param year - of date to add
    * @param rain - rainfall for date to add
    */
   public void insertMonthsRainFallRecord(int month, int year, double rain) {
      int count = 0;
      boolean loop = true;
      RainFall newRF = null; // new RainFall(month, year, rain);
      RainFall tempRF = null;
      while ( loop )
      {
    	  tempRF = monthlyRainList.get(count);
    	  if ( ( month == tempRF.getMonth() ) && ( year == tempRF.getYear() ))
    	  {
    		  System.out.printf("Record for %02d/%d already exists\n",month,year);
    		  System.out.printf("Changing rainfall measure in record from %.2f to %.2f inches",tempRF.getMeasuredRain(),rain);
    		  monthlyRainList.get(count).setMeasuredRain(rain);
    		  loop = false;
    	  }
    	  else if ( (tempRF.getYear() == year ) && (tempRF.getMonth() < month) && (month < monthlyRainList.get(count + 1).getMonth()))
    	  {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else if ( year < tempRF.getYear() ) {
    		  monthlyRainList.add(count, new RainFall(month,year,rain));
    		  loop = false;
    	  }
    	  else
    	  {
    		  			<===10/2009
    		  12/2010
    		  01/2012
    		  02/2012
    		  			<===03/2012
    		  04/2012
    		  01/2014
    		  			<===01/2015
    	  }
    	  
      }
      
   }
 
 
   /**
    * Method writeUpdatedFile will save all data from 
    * the monthlyRainList ArrayList to a file    
    * (IOExceptions handled within the method)
    * Each line written will contain a month number, a 4-digit year, and 
    * the amount of measured rain for that month and year,
    * with each value separated by a space. Sample file output lines:
    * 1 2019 1.35
    * 2 2020 2.51
    * 5 2020 3.62
    * The lines will be stored in chronological order, by date.
	 * 
    * @param FIX ME
	 * @return FIX ME
    */
   public int writeUpdatedFile(String filename) {
      // FIX ME - add method body here for Tests 19 - 22
		
      
      // FIX ME - modify the return value      
		return 0;
   }   
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
